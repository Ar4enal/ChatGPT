1.进程和线程的区别
进程：系统运行的基本单位，包含多个线程

线程：独立运行的最小单位，是进程的实体，多个线程共享同一进程内的系统资源

2. 什么是线程上下文切换
当一个线程被剥夺cpu使用权时，切换到另外一个线程执行

3.什么是死锁
死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局

4.死锁的必要条件
互斥条件：同一资源同时只能由一个线程读取

不可抢占条件：不能强行剥夺线程占有的资源

请求和保持条件：请求其他资源的同时对自己手中的资源保持不放

循环等待条件：在相互等待资源的过程中，形成一个闭环

想要预防死锁，只需要破坏其中一个条件即可，银行家算法可以预防死锁

5.Synchrpnized和lock的区别
（1）synchronized是关键字，lock是一个类

（2） synchronized在发生异常时会自动释放锁，lock需要手动释放锁

（3）synchronized是可重入锁、非公平锁、不可中断锁，lock是可重入锁，可中断锁，可以是公平锁

6.sleep()和wait()的区别
(1)wait()是Object的方法，sleep()是Thread类的方法

(2)wait()会释放锁，sleep()不会释放锁

(3)wait()要在同步方法或者同步代码块中执行，sleep()没有限制

(4)wait()要调用notify()或notifyall()唤醒,sleep()自动唤醒

7.yield()和join()区别
yield()调用后线程进入就绪状态

A线程中调用B线程的join() ,则B执行完前A进入阻塞状态

8.线程池七大参数
核心线程数：线程池中的基本线程数量

最大线程数：当阻塞队列满了之后，逐一启动

最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间

最大线程的存活时间单位

阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列

线程工厂：用于生产线程

任务拒绝策略：阻塞队列满后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争

9.Java内存模型
JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取

具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的

由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题

10.保证并发安全的三大特性？
原子性：一次或多次操作在执行期间不被其他线程影响

可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道

有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排

11.volatile
保证变量的可见性和有序性，不保证原子性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。

单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：申请内存空间，将内存空间引用赋值给变量，变量初始化。如果不禁止重排序，有可能得到一个未经初始化的变量。

12.线程使用方式
(1)继承 Tread 类

(2)实现 Runnable 接口

(3)实现 Callable 接口：带有返回值

13.ThreadLocal原理
原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。

但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value

14.什么是CAS锁
CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是

（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作

（2）CAS频繁失败导致CPU开销大

（3）ABS问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决

15.Synchronized锁原理和优化
Synchronize是通过对象头的markwordk来表明监视器的，监视器本质是依赖操作系统的互斥锁实现的。操作系统实现线程切换要从用户态切换为核心态，成本很高，此时这种锁叫重量级锁，在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁

偏向锁：当一段代码没有别的线程访问，此时线程去访问会直接获取偏向锁

轻量级锁：当锁是偏向锁时，有另外一个线程来访问，偏向锁会升级为轻量级锁，这个线程会通过自旋方式不断获取锁，不会阻塞，提高性能

重量级锁：轻量级锁自旋一段时间后线程还没有获取到锁，线程就会进入阻塞状态，该锁会升级为重量级锁，重量级锁时，来竞争锁的所有线程都会阻塞，性能降低

注意，锁只能升级不能降级

16.JUC常用辅助类
CountDownLatch:设定一个数，当调用CountDown()时数量减一，当调用await() 时判断计数器是否为0，不为0就阻塞，直到计数器为0

CyclicBarrier：设定一个数,当调用await() 时判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值

Semaphore:设定一个信号量，当调用acquire()时判断是否还有信号，有就信号量减一线程继续执行，没有就阻塞等待其他线程释放信号量，当调用release()时释放信号量，唤醒阻塞线程

17.如何根据 CPU 核心数设计线程池线程数量
IO 密集型：核心数*2

计算密集型： 核心数+1

为什么加 1？即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费。
